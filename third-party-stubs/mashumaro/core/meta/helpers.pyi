import typing

def get_type_origin(t): ...
def get_generic_name(t, short: bool = ...) -> str: ...
def get_args(t: typing.Any) -> typing.Tuple[typing.Any, ...]: ...
def get_literal_values(t: typing.Any): ...
def type_name(
    t: typing.Any,
    short: bool = ...,
    type_vars: typing.Dict[str, typing.Any] = ...,
    is_type_origin: bool = ...,
    none_type_as_none: bool = ...,
) -> str: ...
def is_special_typing_primitive(t) -> bool: ...
def is_generic(t): ...
def is_typed_dict(t) -> bool: ...
def is_named_tuple(t) -> bool: ...
def is_new_type(t) -> bool: ...
def is_union(t): ...
def is_optional(t, type_vars: typing.Dict[str, typing.Any] = ...) -> bool: ...
def is_annotated(t) -> bool: ...
def is_literal(t) -> bool: ...
def not_none_type_arg(
    args: typing.Tuple[typing.Any, ...], type_vars: typing.Dict[str, typing.Any] = ...
): ...
def is_type_var(t) -> bool: ...
def is_type_var_any(t) -> bool: ...
def is_class_var(t) -> bool: ...
def is_init_var(t) -> bool: ...
def get_class_that_defines_method(method_name, cls): ...
def get_class_that_defines_field(field_name, cls): ...
def is_dataclass_dict_mixin(t) -> bool: ...
def is_dataclass_dict_mixin_subclass(t) -> bool: ...
def resolve_type_vars(cls, arg_types=..., is_cls_created: bool = ...): ...
def get_name_error_name(e: NameError) -> str: ...
def is_dialect_subclass(t) -> bool: ...
